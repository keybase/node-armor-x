// Generated by IcedCoffeeScript 108.0.11
(function() {
  var BigInteger, Encoding, b58, b62, b64, nbi, nbv, _ref;

  _ref = require('bn'), nbv = _ref.nbv, nbi = _ref.nbi, BigInteger = _ref.BigInteger;

  exports.Encoding = Encoding = (function() {
    function Encoding(alphabet, in_block_len) {
      var a, i, _i, _len, _ref1;
      this.alphabet = alphabet;
      this.in_block_len = in_block_len;
      this.base = this.alphabet.length;
      this.base_big = nbv(this.base);
      this.log_base = Math.log2(this.base);
      this.out_block_len = Math.ceil(8 * this.in_block_len / this.log_base);
      this.max_encoded_bits_per_block = Math.floor(this.log_base * this.out_block_len);
      this.decode_map = {};
      _ref1 = new Buffer(this.alphabet, 'utf8');
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        a = _ref1[i];
        this.decode_map[a] = i;
      }
    }

    Encoding.prototype.encode = function(src, old_shift) {
      var i, inc, _;
      if (old_shift == null) {
        old_shift = false;
      }
      inc = this.in_block_len;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for ((inc > 0 ? (i = _i = 0, _len = src.length) : i = _i = src.length - 1); inc > 0 ? _i < _len : _i >= 0; i = _i += inc) {
          _ = src[i];
          _results.push(this.encode_block(src.slice(i, i + inc), old_shift));
        }
        return _results;
      }).call(this)).join('');
    };

    Encoding.prototype.extra_bits = function(_arg) {
      var decoded_bits, decoded_len, encoded_bits, encoded_len;
      decoded_len = _arg.decoded_len, encoded_len = _arg.encoded_len;
      encoded_bits = encoded_len === this.out_block_len ? this.max_encoded_bits_per_block : Math.floor(this.log_base * encoded_len);
      decoded_bits = decoded_len * 8;
      return encoded_bits - decoded_bits;
    };

    Encoding.prototype.encode_block = function(block, old_shift) {
      var chars, encoded_len, i, num, pad, padlen, r, shift;
      encoded_len = this.encoded_len(block.length);
      shift = this.extra_bits({
        encoded_len: encoded_len,
        decoded_len: block.length
      });
      num = nbi().fromBuffer(block);
      if (old_shift) {
        num = num.shiftLeft(shift);
      }
      chars = (function() {
        var _ref1, _results;
        _results = [];
        while (num.compareTo(BigInteger.ZERO) > 0) {
          _ref1 = num.divideAndRemainder(this.base_big), num = _ref1[0], r = _ref1[1];
          _results.push(this.alphabet[r.intValue()]);
        }
        return _results;
      }).call(this);
      chars.reverse();
      padlen = encoded_len - chars.length;
      pad = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < padlen; i = _i += 1) {
          _results.push(this.alphabet[0]);
        }
        return _results;
      }).call(this);
      return (pad.concat(chars)).join('');
    };

    Encoding.prototype.encoded_len = function(n) {
      var nblocks, out, rem;
      if (n === this.in_block_len) {
        return this.out_block_len;
      } else {
        nblocks = ~~(n / this.in_block_len);
        out = nblocks * this.out_block_len;
        if ((rem = n % this.in_block_len) > 0) {
          out += Math.ceil(rem * 8 / this.log_base);
        }
        return out;
      }
    };

    Encoding.prototype.decode = function(src, old_shift) {
      var bufs, dst;
      if (old_shift == null) {
        old_shift = false;
      }
      src = new Buffer(src, 'utf8');
      bufs = (function() {
        var _ref1, _results;
        _results = [];
        while (src.length) {
          _ref1 = this.decode_block(src, old_shift), dst = _ref1[0], src = _ref1[1];
          _results.push(dst);
        }
        return _results;
      }).call(this);
      return Buffer.concat(bufs);
    };

    Encoding.prototype.decode_block = function(src, old_shift) {
      var c, consumed, d, decoded_len, i, pad, padlen, res, ret, shift, src_p, _i, _len;
      res = nbv(0);
      consumed = 0;
      for (src_p = _i = 0, _len = src.length; _i < _len; src_p = ++_i) {
        c = src[src_p];
        if (!((d = this.decode_map[c]) != null)) {
          continue;
        }
        res = res.multiply(this.base_big).add(nbv(d));
        if (++consumed === this.out_block_len) {
          break;
        }
      }
      ret = consumed === 0 ? new Buffer([]) : (decoded_len = this.decoded_len(consumed), shift = this.extra_bits({
        encoded_len: consumed,
        decoded_len: decoded_len
      }), old_shift ? res = res.shiftRight(shift) : void 0, res = new Buffer(res.toByteArray()), padlen = this.decoded_len(consumed) - res.length, pad = new Buffer((function() {
        var _j, _results;
        _results = [];
        for (i = _j = 0; _j < padlen; i = _j += 1) {
          _results.push(0);
        }
        return _results;
      })()), Buffer.concat([pad, res]));
      return [ret, src.slice(src_p + 1)];
    };

    Encoding.prototype.decoded_len = function(n) {
      var nblocks, out, rem;
      if (n === this.out_block_len) {
        return this.in_block_len;
      } else {
        nblocks = ~~(n / this.out_block_len);
        out = nblocks * this.in_block_len;
        if ((rem = n % this.out_block_len) > 0) {
          out += Math.floor(rem * this.log_base / 8);
        }
        return out;
      }
    };

    return Encoding;

  })();

  exports.b58 = b58 = {
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
    in_block_len: 19
  };

  exports.b58.encoding = new Encoding(b58.alphabet, b58.in_block_len);

  exports.b62 = b62 = {
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',
    in_block_len: 32
  };

  exports.b62.encoding = new Encoding(b62.alphabet, b62.in_block_len);

  exports.b64 = b64 = {
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    in_block_len: 3
  };

  exports.b64.encoding = new Encoding(b64.alphabet, b64.in_block_len);

}).call(this);
